# Important git commands
- `git help [command]` - to get info about the command.
- `git config --global user.[key] "value"` - to add user details in config file. And `key` can be name, email etc.
- `git config --global core.editor "[editor].exe -multiInst -nosession"` - to config default editor.
- `git config --global --list` - list all the configurations which are done at global/user level.
- `git config --global -e` - allow to edit .gitconfig file ith default editor.
- `cat ~/.gitconfig` - print the content of the file which is located in user directory.
- `git config --global merge.tool p4merge` - to set merge tool to resolve conflict while merging.
- `git config --global mergetool.p4merge.path "C:\Program Files\Perforce/p4merge.exe"` - to give path to merge tool.
- `git config --global mergetool.promt false` - to tell git not to promt whether or not to launch p4merge.
- Following commands are for configuration of diff tool -
```
git config --global diff.tool p4merge
git config --global difftool.p4merge.path "C:\Program Files\Perforce/p4merge.exe"
git config --global difftool.promt false
```
- `ls -al` - list all file and floder in the current working directory.
- `mkdir [folder name]` - to create a folder with sepcified name.
- `clear` - to clear the bash window means delete all the previous content. But, previously used comment are still accessable using arrow keys.
- `git init [project name]` - to create a git repository with specified name and that folder contains `.git` folder initially.
- Working directory (or files and folders), staging area and repository(or .git folder) are managed by git locally. Remote repository is also an another repository which also contains all these three stages of its own.
- `git status` - to see status of working directory (like file is modified or added or nothig is done).
- `npp [file name with extension]` - to create a file with given name and open Notepad++ editor(as alias npp stands for Notepad++) to write content of the file.
- `git add README.md` - move edited README file from working directory to staging area.
- `git commit -m "README edited"` - all the files move from staging area to repository area with the given commit message.
- Folder where `.git` folder is present is working directory of git. `.git` is actual git repository which git manages internally. If we delete `.git` folder then we will be no longer on any branch and that folder cant be recognised as git repository. So, if we type `git status` command in working folder we get error message "not a git repository( or any of the parent directories)"
- `cd .git` - to move to .git folder.
- `rm -rf .git` - to remove .git folder forcefully and recursively.
- `git init` - to initialize an empty git repository in the current working folder. But this .git folder has no prior knowledge of the present files and folders and it start fresh. So, when we type `git status` it shows every files in the current directory as untracked files and we have to make commit to create record of those files in git repository.
- `git add .` - to move all the edited files from working directory to git staging area.
- `git commit` - to commit all the changes and and open git core editor which is configured to write commit message.
- `git log` - to see all the commits with commit id, date, author and commit message.
- `git show` - to see all the info wwhich we can get using `git log` command including changes in all the edited files.
- When a new file is commited once then that file is tracked by Git and when the file is modified then git shows that file as modified and not as untracked. But a new file is shown as untracked file as its not be commited even for a single time.
- `git ls-files` - show all the files which git is tracking. It not shows the files which is newly created and not commited.
- `touch [file name with extension]` - to create a file with the given name.
- `git commit -am "[commit message]"` - to commit the changes without moving files to staging area seperately. This command is not applicable for untracked file.
- `git restore --staged [file name]` - to move file back from staging area to working directory.
- `git restore [file name]` - to undo changes in working directory.
- `git checkout -- [file name]` - to undo changes in the file and back to the last commited version. This is applicable if file is in working directory not in staging area.
- `git help log` - to know more about various options for `log` command.
- `git log --oneline --graph --decorate --all` - show each commit message in one single line, (graph) with branch hierarchy, (decorate) and which commits belong to which branches, (all) for all the branches in the git repository.
- `git config --global alias.[aliased name] "[command to be aliased]"` - to make an alias for a long command. For example `git config --global alias.hist "log --oneline --graph --decorate --all"` to create an alias named `hist`.
- `git hist -- LICENSE.md` - show the git log pertaining only to LICENSE.md file.
- `git mv [file name] [changed name]` - to rename the given file. And, after changing the name the file is in staging area and we have to commit the change.
- `mv [file name] [changed name]` - here we use bash mv command instead of git mv command. And, here status is shown as `file name` is deleted and a new `changed name` file is added and its an untracked file. And, to move all to staging area we can use `git add -A` command.
- `git rm [file name]` - to delete the file. And, after this command file is in staging area and we can restore the file from there or can delete permanently by commiting that.
- `git add -u` - move all the deleted file to staging area, but not other kind of files.
- `git add -A` - move all the deelted and added files to staging area.
- If we use bash command instead of git command then file will be in working directory not in staging area. Like `rm [file name]` to delete a file. And to permanently delete the file we have to add that in staging area and then commit.
- In `.gitignore` file we can write the name or the expression of files which we want to ignore. And all those file will not be in git repository but in file system. Even if the ignored file is modified it will not be shown by `git status` command, means we dont have to move that file to staging area and make commit.
- `git diff [commit_id] [commit_id]` - to get difference between two commits. We can use HEAD as latest commit. If we dont give any commit ids then it will give difference between HEAD and latest uncommited changes. 
- `git difftool [commit_id] [commit_id]` - we see the same as `git diff` command but we see in configured difftool which is p4merge in this case.
- Branch is timeline of commits. Branch name is label for commits. 
- Merging is three types -
  - Fast-forward merge: When there is no commit in parent branch and then feature branch commits is simply mergeed with parent branch.
  - Automatic merge: When git detects non-conflicting commit in the parent branch then git do automatic merging and parent timeline is preserveed and new commit is made on parent branch to show merging of branches.
  - Manual: Where automatic merging is not possible and conflicting merge status exists.

- `git diff [branch name] [branch name]` - to see difference between two branches.
- `git branch` - to see all the brances in git repository.
- `git checkout -b [brance name]` - to create a new branch with the given name. And, we move to that branch and also if there is any uncommited change in the parent branch (even if its in staging area) then those changes will be moved on the new branch as uncommited chnages.
- `git checkout [branch name]` - to change git branch.
- HEAD is not just pointing to last commit but pointing to the last commit of the current branch.
- `git merge [branch name]` - to merge the given branch with the current branch. 
- `git branch -d [branch name]` - to delete the given branch. After merging if we delete the branch there is no problem as all the commits on that branch is already merged with current working branch.
- `cat [file name]` - to see the file content in git bash.
- `git mergetool` - to open configured mergetool to resolve merge conflict. When there is merge conflict means auto merging is not possible then we have to do manual merge. Mergetool has various options to choose to resolve conflict. After resolving conflict we have to commit. After resolving conflict a `[file name with extension].orig` file will be generated which contains original content of the file. Here file `[file name]` is the file which had conflict. We can add the `.orig` file to `.gitignore` and then we can remove that file.
-  `git tag [tag name]` - to create light weight tag. If we dont specify commit id then tag will be assigned to HEAD.
-  `git tag --list` - to list all the tags.
-  `git tag -d [tag name]` - to delete the tag.
-  `git show` - to see the details of latest commit on the current branch.
-  `git tag -a [tag name like v1.0] -m "[note like release note]"` - to create annotated tag with given note. If we dont specify commit id then tag will be assigned to HEAD.
-  `git show [annotated tag name]` - to show tag message along with commit detail to which tag is associated with.
-  `git stash` - to save the last changes and it will not be shown in `git status` command as uncommited change though the change is not commited. And file will be same as before making the changes.
-  `git stash list` - to show all the stash.
-  `git stash pop` - to bring the changes back and the files will be same as before `git stash` command. If there are multiple stash then this command works like `stack pop` command means pop the last stash first and others changes will not be brought back. We have to give the command as many times as the number of stash listed to bring all the changes back. Here merge conflict is possible.
-  `git reset [commit id] --soft` - to move HEAD to that commit id. And, all the changes will be instaging area.
-  `git reset [commit id] --mixed` - to move HEAD to the commit if and its default mode. And, changes will be in working directory means we have to move that in staging area.
-  `git resert [commit id] --hard` - to move HEAD tot he commit id and it changes all the file directly to that commit status means we dont have to move file to staging area or dont have to commit.
-  `git log` command show the commits from where the HEAD is pointing but not after that.
-  `git reflog` - show all log including `commit` or `reset` status.
-  `git remote add origin [remote git repository url]` - To set remote repository with referenced name origin. We can use different name inplace of origin.
-  `git remote -v` - to see all the remote repository.
-  `git push -u origin main --tags` - to push local branch `main` to remote repository. `-u` stands for tracking branch relationship, so after the first command we dont need `-u` any more. `--tags` means we want to push all the tags also which are in local git repository in the remote repository. And, `origin` is the remote repository reference. `main` is the branch which we want to push up.
- `git push` - it only push the changes on the current working branch to remote repo matching branch.
-  To generate ssh key follow the following steps - 
    - `cd ~` - to move to home directory.
    - `mkdir .ssh` give this command in home directory of the PC or User.
    - `cd .ssh` - to move to that folder.
    - `ssh-keygen -t rsa -C "[mail id]"` - to generate public/private key pair. ANd, there will be a promt to enter the file to which we want to save the key and just hit `enter` to choose the default.
    - Then there will be promt to give passphrase and again to re-enter it.
    - After the above steps in `.ssh` foler there will be two file - `id_rsa` and `id_rsa.pub` which holds keys for private and public rsa key pair respectively.
    - `npp id_rsa.pub` - to open this file with default code editor(Notepad++) and copy all the contents and put that in SSH key part in `GitHub settings`.
    - `ssh -T git@github.com` - to check we can connect github with ssh key. If yes then it shows successfully authenticated.

- `git clone [git repo url(https/ssh)]` - to create a local copy of the git repository with git repo name by default. And, the remote repo is referenced by `origin` by default.
- `git clone [git repo url(https/ssh)] [new name]` - to create a local copy of the git repository with the given name.
- `cp -R [source file path] [destination folder path]` - to copy the source file to destination folder.
- `cp -R ~/[source folder path from home directory]/* .` - to copy all contents from source folder to current working directory.
- `git fetch` - to fetch all the changes made on remote repository to local repo. It will not merge the chnages.
- `git pull` - to fetch and merge the changes made on remote repo and it also cause merge conflict depending upon the changes. Its basically combiination of fetch and merge command.
- `git remote show origin` - to details about the remote reference origin.
- 
